# Dynamic Programming?
---
## Dynamic Programming
> 한국말로는 "동적 계획법"이라고 한다.  
> 어떤 한 복잡한 문제를 여러개의 문제로 쪼개어 하나씩 해결한 뒤 합치는 방식이다.
> 대표적인 예로, 최단 경로 문제 혹은 행렬의 제곱 문제에 유용하게 사용될 수 있다.  

- Example : 1463 - 1로 만들기
```python
n = int(input())

dp = [0 for _ in range(n+1)]

for i in range(2, n+1):
    dp[i] = dp[i-1] + 1
    if i%2 == 0 and dp[i] > dp[i//2] + 1:
        dp[i] = dp[i//2] + 1
    if i%3 == 0 and dp[i] > dp[i//3] + 1:
        dp [i] = dp[i//3] + 1

print(dp[n])
```
1. X를 3으로 나눈다.  
2. X를 2로 나눈다.  
3. X - 1을 한다.  

위의 3가지 연산만을 사용하여 1을 만들 때 드는 연산의 최솟값을 출력하는 문제이다.  

dp[i] 라는 리스트를 만들어놓고, 거기에 값을 계속해서 갱신한다.  

생각의 전개 방식은 이렇다. 예를 들어 10이라는 숫자를 받았다고 가정하자.  
dp[10]의 최솟값은 dp[10//2] + 1 일 수도, dp[10-1] + 1 일 수도 있다.  
그러면, 또 그 안에서 나오는 dp[5]의 최솟값은 dp[4] + 1, dp[9]의 최솟값은 dp[8] + 1 이거나, dp[3] + 1 일 것이다.  
이런 방식으로 계속 쭉쭉 뻗어나가므로, dp[1] 부터 차곡차곡 쌓아가는 것이다. 뒤에 붙는 1은 Counter의 개념.  
dp[i] > dp[i//2] + 1 의 조건이 붙는 것은 최솟값을 구하는 코드이기 때문이다.  

## Memoization
> 보통 Dynamic Programming을 할 때, 재귀로 짜는 방식을 택하는 경우도 많은데,  
> 그 방식과는 다르게 위와 같이 배열을 만들어 이전 연산 값을 저장해서 꺼내 씀으로써 연산 시간을 줄이는 것이 바로 Memoization이다.  
> 대표적으로 피보나치 수열을 메모이제이션을 이용해 만들 수 있다.  
