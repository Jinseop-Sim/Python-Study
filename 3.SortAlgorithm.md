# Soriting Algorithm
---
## Bubble Sort
> 현재 배열의 요소와 그 다음 배열의 요소를 비교하여, 조건에 부합하면 자리를 바꾸는 방식의 정렬이다.  
> 그럼 가장 큰 수가 제일 뒷 인덱스로 가게 되는데, 이 행위를 정렬이 완료될 때 까지 인덱스를 하나씩 줄이며 반복.  
- ex)
- 8 9 3 1 2 ==> 9 8 3 1 2 ==> .. ==> 9 3 1 2 8
- 3 9 1 2 8 ==> 3 1 9 2 8 ==> .. ==> 3 1 2 8 9
- 1 3 2 8 9 ==> 1 2 3 8 9 
- 위와 같은 순서로 진행된다. 이는 시간복잡도 O(N^2)에 해당하는 정렬 알고리즘이다.
 
## Insert Sort
> 배열 내의 값에서 Key를 하나 정한다.  
> Key의 위치부터 배열의 처음으로 가며 검사를 해서, Key보다 큰 값은 모두 오른쪽으로 밀고 Key보다 작은 값이 나오면 그 뒤에 Key를 저장한다.  
- ex)
- 8 9 3 1 2 에서 두 번째 원소인 9를 먼저 key로 잡고, key보다 큰 값이 없으므로 제자리에 둔다.
- 다음 원소인 1을 key로 잡고, key보다 모두 큰 값이므로 ==> 1 8 9 3 2
- 다음 원소인 3을 key로 잡고, key보다 작은 값은 1이 있으므로 1까지 Slide ==> 1 3 8 9 2
- 다음 원소인 2를 key로 잡고, key보다 작은 값은 1이 있으므로 1까지 Slide ==> 1 2 3 8 9 
- 이 알고리즘 또한 O(N^2)에 해당하는 정렬 알고리즘이지만, 최선의 경우 O(N)까지 줄일 수도 있다.

## Selection Sort
> 제일 앞 칸부터 자리를 정해놓고, 가장 작은 값이 있는 index를 저장하여 서로 swap을 한다.  
> 제일 마지막 칸 까지 가면 정렬 완료.  
- ex)
- 8 9 3 1 2 를 예로 들어보자.
- 제일 앞 칸인 8을 지정해 놓은 뒤, 가장 작은 값인 1이 있는 3번 index를 minindex로 저장 후 Swap. ==> 1 9 3 8 2
- 그 다음 칸인 9를 지정해 놓은 뒤, 남은 4개의 수 중 최소 값인 4번 index를 minindex로 저장 후 Swap. ==> 1 2 3 8 9
- 정렬이 완전히 끝났는지 마지막 index까지 반복.
- 이 알고리즘 또한 O(N^2)에 해당하는 정렬 알고리즘이다.
