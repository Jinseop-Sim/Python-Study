# Searching
---
## Binary Search(이진 탐색)
## Exhaustive Search(완전 탐색)
### Brute Force
> Brute Force, 무차별 대입(공격)이라고 한다.  
> 가능한 경우의 수를 모두 대입해보는 공격이다.  
> 시간복잡도 O가 매우 커질 수 있으므로 굉장히 연산에 있어서 소모적인 공격이다.  
> 경우의 수를 대강 계산해 본 뒤 가능할 정도이면 사용을 하는 기법이다.  

### Permutation
> Permutation, 순열이다.  
> 확률과 통계에서 배웠던 그 순열이 맞다. 순서에 신경을 쓰며 자리를 옮기는 모든 경우를 말하는 것이다.  

![캡처](https://user-images.githubusercontent.com/71700079/124467025-42e35f00-ddd2-11eb-8135-31b55c4f827f.PNG)  

- 특이하게도 위의 순열을 관찰해보면, N개의 데이터가 있을 때, 1~i 번째 까지의 데이터를 설정을 했을 때  
  i 번째 데이터를 기준으로 최종 순열은 i+1부터 N까지가 모두 내림차순이라는 점이 특이하다.  
ex) 1 3 2 / 2 3 1 / 3 2 1
- 따라서 순열을 구하는 방법은 다음과 같다.

> 순열을 구성할 배열을 A라고 하고, index를 i와 j로 두자. 예로 A = [7,2,3,6,5,4,1]로 가정하겠다.  
> 1. A[i-1] <= A[i]를 만족하는 i중에 가장 큰 값을 찾는다. ==> 현재 i값을 기준으로 모두 내림차순으로 되는 경우를 찾는다는 것이다.  
>    A배열의 경우를 살펴보면 A[i-1] < A[i]가 되는 가장 큰 i는 6인 i = 3이 된다.  
>    
> 2. j >= i 중, A[j] > A[i-1]을 만족하는 가장 큰 j의 값을 찾는다.  
>    현재가 최종 순열 상태이므로, i-1 번째 숫자를 변경하여 최초 순열을 찾아야 한다.
>    A배열을 기준으로 i-1번째 숫자는 3으로 3보다 큰 경우는 6, 5, 4이고 그 중 j값이 가장 큰 경우는 4이다.  
> 3. A[i-1]과 A[j]를 Swap한다.  
>    i-1인 2번째 숫자 3과 j인 5번째 숫자 4를 변경한다.  
>    그럼 배열 A는 [7,2,4,6,5,3,1]이 된다.  
> 4. i 이후의 순열을 모두 뒤집는다.  
>    최초 순열의 상태로 만드는 것이므로, i번째 부터는 오름차순으로 만든다.  
>    그럼 배열 A는 [7,2,4,1,3,5,6]이 된다.  

### Recursion
